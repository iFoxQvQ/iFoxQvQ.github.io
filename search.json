[{"title":"Quest 2 一体机版 beatsaber 节奏光剑 回放+添加模型","url":"/2024/09/29/QuestBSReplay/","content":"节奏光剑(BeatSaber) 一体机版 开启第三人称视角回放功能序言我在网上别人晒的 BeatSaber 的视频的时候，别人录制的是第三人称视角加自定义的角色模型。因为一体机版直接内录是第一人称，FOV有限并且很抖，我就算录下来打的不错的的发给别人，别人也毫无体验感。\n因为如果用 PC 串流会影响延迟，一体机内的 BS 在我用下来体验还算可以，为此我想在一体机内通过第三人称录制出来视频发给别人。\n在简中网几乎铺天盖地的是某家广告水印恶心糊脸的 Quest 一体机版本，第三人称录制大部分都是 PC 端的教程。于是自己就去寻找相关 Mod 并出此教程。\n以下资料都是从网上搜集而来，若有侵权请联系我删除。\n具体步骤首先你得一体机版本得是用 BMBF Patch 过的，然后头显里面得安装 BMBF 这个 APP。\n加载 Mod在头显内打开BMBF，照图内操作即可\n\n依次下载以下模型：VRM Qavatars，这是模型 Mod。Replay 重播Mod，BeatLeader ，重播 Mod 前置 Mod。\n\n\n\n下载完成后点击右上角红色按钮进行同步，待同步完成即可。\n\n模型上传具体步骤\n\n打开 BMBF ，进入 Tools 查看当前头显的局域网 IP 地址。\n通过在头显内 BMBF 内看到的 IP 地址，通过在同一局域网下的 PC 进入网页版 BMBF。\n点击 Upload 功能，上传后缀为 *.vrm 的模型文件即可。\n\n之后进入游戏在主页面左边的 Avatar 就能看到上传的模型。\n\n\n\n\n回放并录制当你完成一场游戏后会出现回放按钮，如图。此时回放功能已经正常了，你只需要打开头显的内录功能，然后点击 WATCH REPLAY 即可。\n不过录出来的视角有点奇怪，在下一节我会放出来我的回放视角参数。\nReplay Mod 有自带录制回放功能，博主没有使用过，感兴趣的可以自行探索（评论区开放）。\n\n\n回放视角参数示例：\n\n在 REPLAY SETTINGS 里设置\n以下设定 必须 得开第三人称视角不然会没法加载模型头部，而且也没法调整视角朝向。\n这里的 Enable Avatar 必须关，不然原版模型会挡住你的模型。\n\n\n","categories":["游戏"],"tags":["Quest","beatsaber"]},{"title":"OverTheWire闯关笔记Bandit篇","url":"/2024/07/01/OverTheWireBandit/","content":"\nOverTheWire闯关笔记前往连接OverTheWire: Wargames\nBandit0级此级别的目标是让您使用 SSH 登录游戏。 您需要连接的主机位于端口 2220 上的bandit.labs.overthewire.org。 用户名是 bandit0，密码是 bandit0。\n利用工具\nssh\nssh -p 2220 bandit0@bandit.labs.overthewire.org\n\n1级下一级的密码存储在主目录中的名为 readme 的文件中。使用此密码进行记录 使用 SSH 进入 bandit1。每当您找到关卡的密码时， 使用 SSH（在端口 2220 上）登录该关卡并继续游戏。\n利用工具\nssh\n\nZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If\n\nssh -p 2220 bandit1@bandit.labs.overthewire.org\n\n2级下一级的密码存储在名为 - 的文件中，该文件位于主目录中\n利用工具\nssh\n难点：特殊字符的文件夹\n请使用 cat ./- 打开\n\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx\n\nssh -p 2220 bandit2@bandit.labs.overthewire.org\n\n3级下一级的密码存储在名为空格的文件中 在此文件名中位于主目录中\n利用工具\nssh\n难点：特殊字符的文件夹\n请使用 cat &quot;&quot; 打开\n\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx\n\nssh -p 2220 bandit3@bandit.labs.overthewire.org\n\n4级下一级的密码存储在 inhere 目录的隐藏文件中。\n利用工具\nssh\n\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ\n\nssh -p 2220 bandit4@bandit.labs.overthewire.org\n\n5级下一级的密码存储在唯一人类可读的密码中 文件。提示：如果您的终端混乱 向上，尝试 “重置” 命令。\n利用工具\nssh\n\n4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\n\nssh -p 2220 bandit5@bandit.labs.overthewire.org\n\n6级下一级的密码存储在以下某处的文件中 inhere 目录，并具有以下所有属性：\n\n人类可读\n大小为 1033 字节\n不可执行\n\n利用工具\nssh\n难点：在大量内容内查询文件\n\nfind . -type f -readable ! -executable -size 1033c\n\n\n类型为普通文件（-type f）\n可读（-readable）\n不可执行（! -executable）\n大小为 1033 字节（-size 1033c）\n\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG\n\nssh -p 2220 bandit6@bandit.labs.overthewire.org\n\n7级下一关的密码存储在 server 的某个地方，并具有以下所有属性：\n\n由用户 Bandit7 拥有\n由 Group Bandit6 拥有6\n大小为 33 字节\n\n利用工具\nssh\n难点：find指令的运用\nfind / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null\n\n\n/：从根目录开始搜索。\n-user bandit7：查找所有者是 bandit7 的文件。\n-group bandit6：查找组是 bandit6 的文件。\n-size 33c：查找文件大小正好是 33 字节的文件（c 表示字节）。\n2&gt;/dev/null：将错误消息（例如权限被拒绝的错误）重定向到 /dev/null 以保持输出干净。\n\n\nmorbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\n\nssh -p 2220 bandit7@bandit.labs.overthewire.org\n\n8级The password for the next level is stored in the file data.txt next to the word millionth\n下一级的密码存储在data.txt的百万分之一单词旁边的文件\n利用工具\nssh\n\ngrep: 搜索文本文件中匹配指定模式的行。\nsort: 对文本文件的行进行排序。\nuniq: 报告或省略重复的行。\n\ngrep &quot;millionth&quot; data.txt\n\n\ndfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc\n\nssh -p 2220 bandit8@bandit.labs.overthewire.org\n\n9级下一级的密码存储在文件data.txt中，并且是唯一只出现一次的文本行\n利用工具\nssh\nsort data.txt | uniq -u\n\n\n4CKMh1JI91bUIZZPXDqGanal4xvAg0JM\n\nssh -p 2220 bandit9@bandit.labs.overthewire.org\n\n10级下一级的密码存储在文件中，data.txt在为数不多的人类可读字符串之一中，前面有几个“&#x3D;” 字符。\n利用工具\nssh\n\n使用 strings 命令提取人类可读字符串\n使用 grep 命令过滤包含“&#x3D;”字符的字符串\n\nstrings data.txt | grep &quot;=&quot;\n\n\nFGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey\n\nssh -p 2220 bandit10@bandit.labs.overthewire.org\n\n11级下一级的密码存储在文件data.txt中， 其中包含 base64 编码数据\n利用工具\nssh\ncat data.txt | base64 --decode\n\n\ndtR173fZKb0RRsDFSGsg2RWnpNVj3qRr\n\nssh -p 2220 bandit11@bandit.labs.overthewire.org\n\n12级下一级的密码存储在文件data.txt中， 其中所有小写 （a-z） 和大写 （A-Z） 字母都为 旋转 13 个位置\n利用工具\nssh\ncat data.txt | tr &#x27;A-Za-z&#x27; &#x27;N-ZA-Mn-za-m&#x27;\n\n\n7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4\n\nssh -p 2220 bandit12@bandit.labs.overthewire.org\n\n13级下一级的密码存储在文件data.txt中， 这是重复压缩的文件的十六进制转储。 对于此级别，在 &#x2F;tmp 下创建一个目录可能很有用 你可以工作。使用难以猜测的目录名称的 mkdir。 或者更好的是，使用命令“mktemp -d”。 然后使用 cp 复制数据文件，并使用 mv 重命名它\n利用工具\nssh\n使用 mktemp 创建一个难以猜测的临时目录\ntmp_dir=$(mktemp -d) echo &quot;Temporary directory created: $tmp_dir&quot;\n\n将 data.txt 文件复制到临时目录，并重命名。\ncp data.txt &quot;$tmp_dir/data.txt&quot;cd &quot;$tmp_dir&quot;\n\n 将16进制转为2进制\ncat data.txt | xxd -r &gt; data\n\n用 file 来查看文件属性，再用gzip -d、bzip2 -d、tar -xf解压\n\nFO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn\n\nssh -p 2220 bandit13@bandit.labs.overthewire.org\n\n14级下一级的密码存储在 &#x2F;etc&#x2F;bandit_pass&#x2F;bandit14 中，只能由用户读取 bandit14 。对于此级别，您不会获得下一个密码，但您 获取可用于登录下一关的私有 SSH 密钥。\n难点：要先更改权限700\nchmod 700 sshkey.private\n\n\n-----BEGIN RSA PRIVATE KEY-----MIIEpAIBAAKCAQEAxkkOE83W2cOT7IWhFc9aPaaQmQDdgzuXCv+ppZHa++buSkN+gg0tcr7Fw8NLGa5+Uzec2rEg0WmeevB13AIoYp0MZyETq46t+jk9puNwZwIt9XgBZufGtZEwWbFWw/vVLNwOXBe4UWStGRWzgPpEeSv5Tb1VjLZIBdGphTIK22Amz6ZbThMsiMnyJafEwJ/T8PQO3myS91vUHEuoOMAzoUID4kN0MEZ3+XahyK0HJVq68KsVObefXG1vvA3GAJ29kxJaqvRfgYnqZryWN7w3CHjNU4c/2Jkp+n8L0SnxaNA+WYA7jiPyTF0is8uzMlYQ4l1Lzh/8/MpvhCQF8r22dwIDAQABAoIBAQC6dWBjhyEOzjeAJ3j/RWmap9M5zfJ/wb2bfidNpwbB8rsJ4sZIDZQ7XuIh4LfygoAQSS+bBw3RXvzEpvJt3SmU8hIDuLsCjL1VnBY5pY7Bju8g8aR/3FyjyNAqx/TLfzlLYfOu7i9Jet67xAh0tONG/u8FB5I3LAI2Vp6OviwvdWeC4nOxCthldpuPKNLA8rmMMVRTKQ+7T2VSnXmwYckKUcUgzoVSpiNZaS0zUDypdpy2+tRH3MQa5kqN1YKjvF8RC47woOYCktsDo3FFpGNFec9Taa3Msy+DfQQhHKZFKIL3bJDONtmrVvtYK40/yeU4aZ/HA2DQzwheol1AfiEhAoGBAOnVjosBkm7sblK+n4IEwPxs8sOmhPnTDUy5WGrpSCrXOmsVIBUflaL3ZGLx3xCIwtCnEucB9DvN2HZkupc/h6hTKUYLqXuyLD8njTrbRhLgbC9QrKrSM1F2fSTxVqPtZDlDMwjNR04xHA/fKh8bXXyTMqOHNJTHHNhbh3McdURjAoGBANkU1hqfnw7+aXncJ9bjysr1ZWbqOE5Nd8AFgfwaKuGTTVX2NsUQnCMWdOp+wFak40JHPKWkJNdBG+ex0H9JNQsTK3X5PBMAS8AfX0GrKeuwKWA6erytVTqjOfLYcdp5+z9s8DtVCxDuVsM+i4X8UqIGOlvGbtKEVokHPFXP1q/dAoGAcHg5YX7WEehCgCYTzpO+xysX8ScM2qS6xuZ3MqUWAxUWkh7NGZvhe0sGy9iOdANzwKw7mUUFViaCMR/t54W1GC83sOs3D7n5Mj8x3NdO8xFit7dT9a245TvaoYQ7KgmqpSg/ScKCw4c3eiLava+J3btnJeSIU+8ZXq9XjPRpKwUCgYA7z6LiOQKxNeXH3qHXcnHok855maUj5fJNpPbYiDkyZ8ySF8GlcFsky8Yw6fWCqfG3zDrohJ5l9JmEsBh7SadkwsZhvecQcS9t4vby9/8X4jS0P8ibfcKS4nBP+dT81kkkg5Z5MohXBORA7VWx+ACohcDEkprsQ+w32xeDqT1EvQKBgQDKm8ws2ByvSUVs9GjTilCajFqLJ0eVYzRPaY6f++Gv/UVfAPV4c+S0kAWpXbv5tbkkzbS0eaLPTKgLzavXtQoTtKwrjpolHKIHUz6Wu+n4abfAIRFubOdN/+aLoRQ0yBDRbdXMsZN/jvY44eM+xRLdRVyMmdPtP8belRi2E2aEzA==-----END RSA PRIVATE KEY-----\n\nssh -i sshkey.private bandit14@bandit.labs.overthewire.org -p 2220\n\n15级The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.\n\n\nMU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS\n\nssh -p 2220 bandit14@bandit.labs.overthewire.org\n\n8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo\n\nssh -p 2220 bandit15@bandit.labs.overthewire.org\n\n16级可以通过提交 当前级别的密码到 localhost 上的端口 30001 使用 SSL 加密。\n\nopenssl s_client是使用 SSL&#x2F;TLS 连接到服务器的简单客户端的实现。\n\nopenssl s_client -connect localhost:30001\n\n\n\nkSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n\nssh -p 2220 bandit16@bandit.labs.overthewire.org\n\n17级可以通过提交 当前级别的密码到 localhost 上的端口，在 31000 到 32000。首先找出这些端口中哪些有服务器 倾听他们。然后找出哪些说SSL，哪些说SSL 不要。只有 1 台服务器将提供下一个凭据，即 其他人只会将您发送给它的任何东西发回给您。\nnmap -p 31000-32000 -sV localhost\n\n\n31046&#x2F;tcp open  echo\n31518&#x2F;tcp open  ssl&#x2F;echo\n31691&#x2F;tcp open  echo\n31790&#x2F;tcp open  ssl&#x2F;unknown\n31960&#x2F;tcp open  echo\n\n\necho &quot;kSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx&quot; | openssl s_client -connect localhost:31790 -ign_eof\n\nkSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx\n\n-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----\n\nssh -i sshkey.private bandit17@bandit.labs.overthewire.org -p 2220\n\n18级主目录中有 2 个文件：passwords.old 和 passwords.new。下一级的密码位于 passwords.new 中，并且是 passwords.old 和 passwords.new 之间唯一已更改的行\n注意：如果您已经解决了此级别并在尝试时看到“再见！ 要登录 Bandit18，这与下一个级别 Bandit19 有关\nEReVavePLFHtFlFsjn3hyzMlvSuSAcRD\n\nssh -p 2220 bandit17@bandit.labs.overthewire.org\n\ndiff passwords.old passwords.new\n\n\nbSrACvJvvBSxEM2SGsV5sn09vc3xgqyp\n\nx2gLTTjFwMOhQ8oWNbMN362QKxfRqGlO\n\nssh -p 2220 bandit18@bandit.labs.overthewire.org\n\n\n19级下一级的密码存储在文件自述文件中 主目录。不幸的是，有人修改了 .bashrc 以在您使用 SSH 登录时将您注销。\n我们不是使用 SSH 登录计算机，而是通过 SSH 执行命令。首先，我们用来确保自述文件在文件夹中，然后我们可以用来读取它。\n$ ssh bandit18@bandit.labs.overthewire.org -p 2220 ls         This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: readme$ ssh bandit18@bandit.labs.overthewire.org -p 2220 cat readme This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: cGWpMaKXVwDUNgPAVJbWYuGHVn9zl3j8\n\ncGWpMaKXVwDUNgPAVJbWYuGHVn9zl3j8\n\nssh -p 2220 bandit19@bandit.labs.overthewire.org\n\n20级要访问下一级别，您应该使用 setuid 二进制文件 在主目录中。在没有参数的情况下执行它，以了解如何 使用它。此级别的密码可以在通常的 放置 （&#x2F;etc&#x2F;bandit_pass），在您使用 setuid 二进制文件之后。\n首先，我们检查 setuid 二进制文件的所有者是谁：\nls -la\n\n\n./bandit20-do cat /etc/bandit_pass/bandit20\n\n在本例中，所有者是 badit20，组是 bandit19，其中 ‘-rwsr-x—‘ 表示用户 bandit19 可以执行二进制文件，但二进制文件以用户 bandit20 身份执行。\n执行二进制文件表示它只是以另一个用户的身份执行另一个命令（如前所述，这个用户是 bandit20）。这意味着我们可以访问 bandit20 用户密码文件，该文件只能由用户 bandit20 读取。\n\n0qXahG8ZjOVMN9Ghs7iOWsCfZyXOUbYO\n\nssh -p 2220 bandit20@bandit.labs.overthewire.org\n\n21级主目录中有一个 setuid 二进制文件，它执行以下操作：它在指定为命令行参数的端口上与 localhost 建立连接。然后，它从连接中读取一行文本，并将其与上一级 （bandit20） 中的密码进行比较。如果密码正确，它将传输下一关（bandit21）的密码。\n\n使用“netcat”，我们可以在服务器模式下创建一个连接 - 该连接侦听入站连接。为了让 netcat 发送密码，我使用 echo 并将其通过管道传输到 netcat。\n使用端口 1234 运行 setuid 二进制文件意味着它将连接到我们的 netcat 服务器，接收输入的密码并发回下一个密码。\n\n\nEeoULMCra2q0dSkYj561DX7s1CpBuOBt\n\nssh -p 2220 bandit21@bandit.labs.overthewire.org\n\n22级程序从基于时间的作业调度程序 cron 定期自动运行。在 &#x2F;etc&#x2F;cron.d&#x2F; 中查找配置，并查看正在执行的命令。\n\n首先，我们看一下“&#x2F;etc&#x2F;cron.d”文件夹中的内容。具体来说，对于这个级别，我查看了 cronjob ‘cronjob_bandit22’。\n\n此 cronjob 以 bandit22 用户身份运行文件。五颗星表示它每分钟都在运行，每天都在运行。要知道到底执行了什么，我们需要看一下 bash 文件。&#x2F;usr&#x2F;bin&#x2F;cronjob_bandit22.sh\n\n此文件在“tmp”文件夹中创建一个文件，并向所有人授予读取权限（由最后 4 个表示）。然后，它将 bandit22 密码文件的输入复制到新创建的文件中。\n\n因此，下一级的密码在此创建的文件中：\n\n\n\ntRae0UfB9v0UzbCdn9cY0gQnds9GF58Q\n\nssh -p 2220 bandit22@bandit.labs.overthewire.org\n\n23级","categories":["学习"],"tags":["网络安全"]},{"title":"Vue3 实现简单的仿 Gemini 界面","url":"/2025/05/20/build_gemini_chat_vue/","content":"前言前段时间做毕设搞了个 AI 对话界面，但是一直都不满意。然后现在答辩完了，继续来搓一个好看点的 AI 对话界面。也练一练自己 JavaScript 和界面排版技能。\n平时 AI 用的 Gemini 最多，也挺好看的，就选它来造了！\n准备Gemini API Key：半个月前部署玩过 my-neuro 然后申请的 API Key，免费方案已经非常够用了。\n申请 API Key 网站\n开始第一步：制作大致布局观察 Gemini 网站的布局，可以分作三大块。\n\n侧边栏\n标题\n对话部分\n\n\n这里我用了 Vue 框架来写， Element-Plus 的布局容器，非常方便。能帮我快速划分工作区块。\n\n成品如下，制作的时候也是花了很多时间，自己一点点对着 Gemini 网站扣了出来，也温习了一下以前学的元素布局方法。\n制作的时候忘记组件化制作，在父组件一股脑往下做。结果一大坨屎山出来了\n\n第二步：实现调用接口然后就是处理调用接口部分了。第一步，先来官网找文档。\nGemini API Key 使用方法\n模型功能有很多，首先就来实现第一个最基本的文本对话功能。\n\n既然是对话聊天 AI ,那么上下文关联很重要。这里官方称为 多轮对话（聊天），而且得选择流式传输，不然得傻傻等半天。\n官方提供的使用方式很清晰，文档已给出链接、调用方式、头部、请求体。\n将用户和 AI 的消息全部放在请求体内，以 POST 的方式对调用链接进行流式传输请求。准备一个空的消息数组将返回的数据进行拼接。处理流式文本，提取文本信息。\n通过查看响应数据，可以找到结尾关键字为 &quot;finishReason&quot;: &quot;STOP&quot; ，其余文本均现将开头的 data:  去掉，转成标准 JSON 格式后，提取 text 里的内容。\n// 这个去掉就是正常 JSON 格式了data: &#123;    &quot;candidates&quot;: [        &#123;            &quot;content&quot;: &#123;                &quot;parts&quot;: [                    &#123;                        &quot;text&quot;: &quot;模型，由 Google 训练。\\n&quot;                    &#125;                ],                &quot;role&quot;: &quot;model&quot;            &#125;,            &quot;finishReason&quot;: &quot;STOP&quot;        &#125;    ],    // 其余相同的...&#125;\n\n获取接口返回的数据，然后将其中的有效文本提取并追加到 messages 内。\ntry &#123;  const response = await fetch(&#x27;https://generativelanguage.googleapis.com/v1beta/models/gemini-&#x27; + model.value + &#x27;:streamGenerateContent?alt=sse&amp;key=&#x27; + apiKey.value, &#123;    method: &#x27;POST&#x27;,    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;application/json&#x27;    &#125;,    body: JSON.stringify(&#123; // 将消息内容转换为 JSON 字符串作为请求体        // 遍历所有上下文      contents: messages.value.map(m =&gt; (&#123;         role: m.role,         parts: [&#123;text: m.content&#125;]       &#125;))    &#125;)  &#125;)  // 检查请求是否成功  if (!response.ok) &#123;    throw new Error(`请求失败，状态码：$&#123;response.status&#125;`) // 如果状态码不是 2xx，则抛出错误  &#125;      // 获取响应体，用于读取流式数据  const reader = response.body.getReader()   // 创建 TextDecoder 实例，用于将 Uint8Array 转换为字符串  const decoder = new TextDecoder()   // 添加一个空的 AI 消息用于拼接流式结果  messages.value.push(&#123;    role: &#x27;model&#x27;,    content: &#x27;&#x27;  &#125;)  // 获取刚刚添加的 AI 消息的索引  const currentIndex = messages.value.length - 1   // 处理文本流的异步函数  const processText = async (&#123;done, value&#125;) =&gt; &#123;    // 如果流已结束    if (done) &#123;      loading.value = false // 设置 loading 状态为 false      return // 结束函数    &#125;\t// 将 Uint8Array 数据块解码为字符串    const chunk = decoder.decode(value, &#123;stream: true&#125;)         // 检查行是否以 &#x27;data: &#x27;开头    if (chunk.startsWith(&#x27;data: &#x27;)) &#123;      try &#123;        // 移除 &#x27;data: &#x27; 前缀并去除首尾空格        const jsonStr = line.replace(/^data: /, &#x27;&#x27;).trim()         // 将 JSON 字符串解析为 JavaScript 对象        const data = JSON.parse(jsonStr)        // 安全地提取生成的内容文本，若任一上级内容为 null ，将返回空字符串        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || &#x27;&#x27;        if (text) &#123;          // 将提取到的文本追加到当前 AI 消息的内容中          messages.value[currentIndex].content += text           await nextTick() // 等待 DOM 更新周期，确保界面更新          scrollToBottom() // 滚动到底部，显示最新内容        &#125;      &#125; catch (e) &#123;        console.warn(&#x27;解析错误:&#x27;, line)      &#125;    // 继续读取下一部分数据并递归调用 processText    await reader.read().then(processText)   &#125;  // 开始读取流数据并处理  await reader.read().then(processText)   saveMessages()&#125; catch (error) &#123;  loading.value = false  messages.value.push(&#123;    role: &#x27;model&#x27;,    content: `❌ 请求失败：$&#123;error.message&#125;`   &#125;)&#125;\n\n输出消息部分使用了 v-for 循环输出存在 messages 里的文本内容，通过读取 role 里面的角色身份来分配响应的样式\n&lt;div v-for=&quot;(message, index) in messages&quot; :key=&quot;index&quot; :class=&quot;message.role&quot;&gt;     &lt;div class=&quot;bubble&quot;&gt;          &lt;span v-html=&quot;md.render(message.content)&quot;&gt;&lt;/span&gt;     &lt;/div&gt;&lt;/div&gt;\n\n可以看到消息如期展示出来\n\n第三步：消息持久化虽然上面是实现了 AI 对话，但是一刷新页面就会导致对话消失，没法保存。这里我使用 LocalStorage 进行长久存储。\n首先，创建出会话 ID。为了让每个会话 ID 尽可能不一样，使用了时间戳来进行制作，防止快速点击新会话，短时间内时间戳没变化导致会话 ID 一致，在末尾又加了 0-1000 的随机数。\nconst now = new Date();const chatId = `$&#123;Date.now()&#125;_$&#123;Math.floor(Math.random() * 1000)&#125;`\n\n然后按照以会话 ID 为 Key ，消息内容为 Value 存储在 LocalStorage 中实现持久化。\n侧边栏选择会话通过 v-for 遍历输出标题，标题的内容为用户说的第一句话的前 10 字，想像官网那样做第一句的总结的，不知道应该怎样实现。\n然后也按照以 chats 为 Key ，会话 ID 和标题内容为 Value 存储在 LocalStorage 中实现持久化。\n最后将加载函数放在生命周期钩子 onMounted 中，每次加载页面的时候就读取存储的内容。\n最后其实最开始写到流式读取的时候用的 ChatGPT 写的，后面逐步修改多余的逻辑简化了 30% 多，也是像这个贴子里的回复说的一样：“虽然它可以工作，但是会写很多糟糕的代码，通常比你需要的行数要多的多。”\n点我前往\n修改的过程也是学习的过程，理解透了的感觉很舒服。\n","categories":["学习"],"tags":["前端","Vue","LLM"]},{"title":"迈入开源世界的第一步：GitHub PR","url":"/2025/05/17/github_pull_request_record/","content":"前言近期在搞毕设，学了制作仿 ChatGPT 对话界面，想着找找还有没有其他实现的方法，在 GitHub 上搜相关项目的时候，找到一个自己觉得可以 PR 的项目，遂记录本人第一次 PR 过程。\nPR流程在网上找了很多关于 PR 的教程，大概可以分为以下几个步骤：\n\n先 Fork 别人的项目到自己的仓库里\nclone 到本地进行修改，修改的时候不会影响到别人的仓库，可以放心修改\n修改完后，push 回自己的仓库\n如果一切就绪，那么就可以提交 PR 请求\n当作者认同你的修改，那么他就会将你的代码合并到 master 上，然后自己也会成为这个项目的 contributor。\n\n正式开始Fork 项目首先 Fork 打算提交 PR 的项目到自己仓库里。\n\n\nClone 到本地进行修改在本地电脑找了个方便修改项目的地方，打开 Git Bash 或者命令行，用以下命令在本地克隆项目的代码库：\ngit clone &lt;repository-url&gt;\n\n这样就能在本地拥有项目的代码了。\n创建分支在本地创建一个新的分支来进行开发工作。\nPS：虽然第一个 PR 从 main 提交完全没有问题，但是如果需要同时提交2个 PR ，新建分支更好工作。\ngit checkout -b &lt;branch-name&gt;\n\n这个命令是在本地创建一个新的分支，并且切换到这个分支。\n可以在这个新分支上进行代码修改和开发。\n更新本地代码在每一次写代码之前，都需要确认本地分支的代码是最新的，不然提交的时候有别人先提交会冲突。\n更新本地 main 代码：\ngit fetch upstreamgit checkout maingit rebase upstream/main# 更新分支的git checkout &lt;branch-name&gt;git rebase main\n\n这里因为我使用的是命令行进行 git clone ，然后使用 git bash 进行更新本地 main ，出现了以下情况。其原因是：Git 在本地仓库配置中找不到远程仓库信息。\n$ git fetch upstreamfatal: &#x27;upstream&#x27; does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.\n\n这时候先查看配置的远程仓库名称以及它们对应的抓取 (fetch) 和推送 (push) URL\n$ git remote -vorigin  https://github.com/iFoxQvQ/cloud-web.git (fetch)origin  https://github.com/iFoxQvQ/cloud-web.git (push)\n\n再手动添加 upstream 远程仓库\n$ git remote add upstream https://github.com/iFoxQvQ/cloud-web.git\n\n此时进行更新就没有问题了。\n解决问题参考的帖子：GitHub - Git 错误 - Stack Overflow\n$ git fetch upstreamFrom https://github.com/iFoxQvQ/cloud-web * [new branch]      main       -&gt; upstream/main\n\n写代码写代码写代码写代码\nCommit 和 Push写完代码后，使用以下命令将代码提交到远程仓库：\ngit add .git commit -s -m &quot;Commit message&quot;git push origin &lt;branch-name&gt;\n\n代码提交到远程仓库后，可以在 GitHub 上创建一个新的 PR 了。\n打开自己 Fork 的仓库页面，在页面上方选择 “ Pull requests ” ，然后点击 “ New pull request ” 按钮。\n\n\n选择修改的分支来进行提交。\n\n然后进行修改 PR 标题和描述内容。完成后点击 Create pull request 按钮。\n\n这样就可以创建一个新的PR了，然后就是等作者同意合并了。\n可能会遇到的问题reviewers 提出修改意见提交 PR 很多时候会因为各种各样的问题不会被马上合入，Reviewers 会提出修改意见。这时可以返回去继续根据意见修改代码，然后通过执行和第一次 Commit 一样步骤的命令，GitHub 会自动把新增的 Commits 全部追加到一个未合入 PR 里去。\nPR 产生冲突每次写代码前应更新本地代码，尽量避免这种情况。但有时候 PR 被阻塞了一段时间，可能别人修改了一行代码，被抢先合入，这时候 PR 就出现冲突了。\n现在本地执行：\n# 先切回到 main 分支git checkout main# 拉取上游代码git fetch upstream# 更新本地 maingit rebase --hard upstream/main\n\n本地的 main 分支就和远程的代码完全一致了，然后将 main 分支代码合入自己的分支，同时解决冲突。\ngit checkout &lt;branch-name&gt;git rebase main\n\n冲突部分内容一般会像以下这样：\n1 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD2 Text 1.3 Text 2 changed by me.4 =======5 Text 1 changed by other.6 Text 2.7 &gt;&gt;&gt;&gt;&gt;&gt;&gt; from upstream/master\n\n将其修改为你认为最好的结果。例如以下三种：\n1 Text 1 changed by other.2 Text 2 changed by me.\n\n1 Text 1 changed by other.2 Text 2.\n\n1 Text 1.2 Text 2 changed by me.\n\n然后保存文件，再进行第一次 PR 操作即可。\ngit add .git commit -s -m &quot;Commit message&quot;git push origin &lt;branch-name&gt;\n\n这里我推荐一个练习自己解决 PR 冲突的课程，自己看后觉得挺不错的。\n使用 GitHub 上的合并冲突解决解决竞争性提交 - Training | Microsoft Learn\n修改少量代码记起之前部署 my-neuro 项目的时候遇到的 bug ，在评论区也看到很多人遇到这个问题，当时忘记 PR 了。\n直接在原仓库找到想要修改的文件，然后选择修改。\n\n修改完毕后提交修改\n\n\n这样节省了很多时间，不需要去 clone 原项目。\n","categories":["学习"],"tags":["github"]}]